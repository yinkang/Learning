#############################################
Mysql Note
Reference to 高性能MySQL
Start with "---" means need attention.
#############################################

1（P121） Difference between Timestamp and DateTime
         +-------------------+------------------------+
　　   | 列类型　　　　   | 显示格式　　  |
　　   | timestamp(14) | yyyymmddhhmmss |　
　　   | timestamp(12) | yymmddhhmmss　 |
　　   | timestamp(10) | yymmddhhmm　    |
　   　| timestamp(8)　| yyyymmdd　         |
　　   | timestamp(6)　| yymmdd　　　　 |
　　   | timestamp(4)　| yymm　　　　　 |
　　   | timestamp(2)　| yy　　　　　　   |
　　   +-------------------+———————  +

你可以在创建表时指定一个任意的显示尺寸，但是定义列长为0或比14大均会被强制定义为列长14。

　　列长在从1～13范围的奇数值尺寸均被强制为下一个更大的偶数。

　　定义字段长度　　 强制字段长度

　　timestamp(0) ->　timestamp(14)
　　timestamp(15)->　timestamp(14)
　　timestamp(1) ->　timestamp(2)
　　timestamp(5) ->　timestamp(6)

2（P113）TinyInt(N) 或者Int(N)里面的N对实际的取值范围、存储和计算都没有任何影响，仅在部分的client端的显示有影响（目前没找到有影响的client）

3（P114）
1)Decimal 最多允许65个数字其中,每9个数字占用4个字节,然后小数点占用1个字节。
2)数据量比较大的时候,可以考虑使用BigInt来实现,将其乘一定的倍数之后,可避免精度丢失以及精确计算的代价高的问题。

4（P115）
1) Varchar
①在5.0及其以后会保留末尾空格,在之前会踢出末尾空格
②适合用于以下情况: 字符串列的最大长度比平均长度大很多;列的更新少;使用了UTF-8这样复杂的字符集。
③需要多余的一个或者两个字节用于存储长度,当长度loe255字节时用一个字节保存,否则用两个字节。
2) Char
①会剔除所有的末尾空格
②适用于: 存储很短的字符串，或者所有值都接近的一个长度。
③在比较时会填充空格
3)binary 与Varbinary（二进制字符串）
保存的是字节码而不是字符串,其他的与varchar与char之间基本类似
---binary在检索时会自动填充 \0 会影响检索效果

5(P118) Blob or text 属于超长的字节码和字符串,可以用order by sustring(column,length)来按照其一部分长度进行排序,但是不能用其所有的长度进行索引,也不能用索引来消除排序（need further learning）

6(P124)
1)Enum 类型在插入的时候是不区分大小写的,但是会按照实际的情况按照实际enum的大小写来 format 如 enum为‘DOG’,插入‘doG’ 就会被format成‘DOG’;
2)Enum 字段这是按照内部存储的整数而不是定义的字符串进行排序的。可以在定义的时候按照字母排序来定义或者使用field()函数。
Related SQL:
select enum_name + 0 from table_name;
select * from table_name order by field('enum_name','type1','type2','type3');

7(P121) query_cache_type
query_cache_type
Related SQL:
show variables like '%query_cache%';
set query_cache_type = 0;

8(P125) 在选择标识符（用于与其他表进行比较如在关联操作的时候）,不同表的标志符的字段必须要精确匹配（类型,长度）。（在InnoDB引擎中,类型不完全匹配时不允许创建外键,但是长度不同的varchar是例外）
推荐使用int,不推荐varchar和enum类型.

9(P132)
1)汇总表: 在需要执行需要查询几乎所有的表的操作的时候,可以使用汇总表,先将其汇总信息保存在一个新表中,使用不完全同步的信息,或者使用增量同步的方式实现信息的完全同步
2)缓存表: 对于一个需要很多不同的索引组合俩加速各种类型的查询,可以再创建一相同的表作为缓存表,而在缓存表中使用不同的引擎或者换到不同的系统中。
3)计数器表,应用在表中保存计数器时,可能会导致锁问题,这时可以将计数器保存在很多行中,每次更新的时候,随机选择一项进行更新。

10(P142)
Btree 索引:MySQL 索引的实现是在引擎层的,如果没有指明索引类型,一般都是BTree索引。BTree 索引适用于全键值、键值范围或者键前缀查找。其中键前缀查找只适用于最左键前缀查找。不支持部分索引。
Hash 索引 :  优点,全值查找时速度非常快。
             限制,①哈希索引只保存哈希值和行指针,并不保存数据值,因此不能使用索引中的值来避免读取行。②因为哈希索引不是按照值排序的,因此无法排序。③不支持部分索引值匹配。④只支持等值匹配如=或者<>,不支持范围查询。
                 ④当两行的哈希值相同时（即哈希冲突）,存储引擎必需遍历链表中所有的行指针,逐行匹配。冲突越多,索引查找速度越慢,索引的维护代价越大。

11(P149)
触发器,可用于在指定在数据在被INSERT,UPDATE和DELETE的时候执行指定的操作,其中有BEFORE 和AFTER 两种时间,与对应的条件组合起来共有6种触发器,一个表不可能有两个相同条件下的触发器,因为一个触发器中可以执行多个语句。
DELIMITER $  /*因为在trigger_stmt中可能有很多个语句,语句之间要用";"分隔,而";"在sql中会被认为是一个语句的结束语句,因此将分隔符改成$或者其他符号都可以*/
CREATE TRIGGER trigger_name
BEFORE|AFTER
INSERT|UPDATE|DELETE ON tbl_name
FOR EACH ROW
BEGIN
[trigger_stmt]
END
DELIMITER ;
在trigger_stmt中可以对不同的数据进行操作,其中NEW标识将要被插入的数据,是允许修改的。OLD标识将要被删除的数据,是只读的。

12(P151)
一些其他的索引:空间数据索引,全文索引,分形树索引。

13(P152)
索引的优点:
减少了服务器需要扫描的数据量
帮助服务器避免排序和临时表
将服务器的随机I/O变成了顺序I/O.

判断一个索引是否适合某个查询的三星标准:
索引将相关的数据放到一起,则为一星。
索引中得数据顺序和查找顺序一致,则为二星
索引中的的列包含了查询中需要的全部的列这获得三星。

14（P154）
使用索引时只能将索引作为一个独立的列,不可用于表达式或者函数的参数 如select
前缀索引与索引选择性:
前缀索引即使用某一个字段的一部分来获取建立索引（如果该字段长度过长）。
InnoDB不支持后缀索引,只能通过将数据翻转后创建前缀索引的方式实现。
索引选择性:指不重复的索引的数量a与总的数据量b的比值,比值越大越好

15(P161)
多列索引（选择合适的索引顺序）
索引选择性越高的越靠前。
(索引选择性高的索引在特殊情况下也可能极慢)。

16(P162)聚簇索引
MySQL InnoDB一定会建立聚簇索引，把实际数据行和相关的键值保存在一块，这也决定了一个表只能有一个聚簇索引，即MySQL不会一次把数据行保存在二个地方。
1)  InnoDB通常根据主键值(primary key)进行聚簇
2) 如果没有创建主键，则会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
3) 上面二个条件都不满足，InnoDB会自己创建一个虚拟的聚集索引
如果主键是一个列前缀索引,InnoDB也会包含完整的主键列和剩下的其他列
优点：
聚簇索引的优点,就是提高数据访问性能。聚簇索引把索引和数据都保存到同一棵B+树数据结构中，并且同时将索引列与相关数据行保存在一起。
这意味着，当你访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。
不同于MyISAM引擎，它将索引和数据没有放在一块，放在不同的物理文件中，索引文件是缓存在key_buffer中，索引对应的是磁盘位置，不得不通过磁盘位置访问磁盘数据。
缺点：
1) 维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。
   建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片
2) 表因为使用UUId作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键
3) 如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间

17(P169)
在InnoDB表中建议按照主键顺序插入行（在高并发的情况下,使用AUTO_INCREMENT的作为主键,会造成明显的主键争用）
InnoDB默认的最大填充因子是页大小的15/16,留出部分空间用于以后修改

18(P171)
如果索引中包含所需要查询的字段的值,我们称之为覆盖索引。
哈希索引,空间索引和全文索引不包含列的值,因此无法实现覆盖索引。目前只有BTree索引支持覆盖索引。
如果覆盖索引包含select时所需的所有的量,则在select无需访问table data

19（P173）---ICP(Index Condition PushDown)索引条件推送
Definition:Without ICP, the storage engine traverses the index to locate rows in the base table
and returns them to the MySQL server which evaluates the WHERE condition for the rows.
With ICP enabled, and if parts of the WHERE condition can be evaluated by using only fields from the index,
the MySQL server pushes this part of the WHERE condition down to the storage engine.
Purpose:The goal of ICP is to reduce the number of full-record reads and thereby reduce IO operations.
This strategy can be used for InnoDB and MyISAM tables.
(Note that index condition pushdown is not supported with partitioned tables in MySQL 5.6; this issue is resolved in MySQL 5.7.)
For InnoDB tables, however, ICP is used only for secondary indexes.

