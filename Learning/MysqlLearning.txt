#############################################
Mysql Note
Reference to 高性能MySQL
Start with "---" means need attention.
#############################################

1（P121） Difference between Timestamp and DateTime
         +-------------------+------------------------+
　　   | 列类型　　　　   | 显示格式　　  |
　　   | timestamp(14) | yyyymmddhhmmss |　
　　   | timestamp(12) | yymmddhhmmss　 |
　　   | timestamp(10) | yymmddhhmm　    |
　   　| timestamp(8)　| yyyymmdd　         |
　　   | timestamp(6)　| yymmdd　　　　 |
　　   | timestamp(4)　| yymm　　　　　 |
　　   | timestamp(2)　| yy　　　　　　   |
　　   +-------------------+———————  +

你可以在创建表时指定一个任意的显示尺寸，但是定义列长为0或比14大均会被强制定义为列长14。

　　列长在从1～13范围的奇数值尺寸均被强制为下一个更大的偶数。

　　定义字段长度　　 强制字段长度

　　timestamp(0) ->　timestamp(14)
　　timestamp(15)->　timestamp(14)
　　timestamp(1) ->　timestamp(2)
　　timestamp(5) ->　timestamp(6)

2（P113）TinyInt(N) 或者Int(N)里面的N对实际的取值范围、存储和计算都没有任何影响，仅在部分的client端的显示有影响（目前没找到有影响的client）

3（P114）
1)Decimal 最多允许65个数字其中,每9个数字占用4个字节,然后小数点占用1个字节。
2)数据量比较大的时候,可以考虑使用BigInt来实现,将其乘一定的倍数之后,可避免精度丢失以及精确计算的代价高的问题。

4（P115）
1) Varchar
①在5.0及其以后会保留末尾空格,在之前会踢出末尾空格
②适合用于以下情况: 字符串列的最大长度比平均长度大很多;列的更新少;使用了UTF-8这样复杂的字符集。
③需要多余的一个或者两个字节用于存储长度,当长度loe255字节时用一个字节保存,否则用两个字节。
2) Char
①会剔除所有的末尾空格
②适用于: 存储很短的字符串，或者所有值都接近的一个长度。
③在比较时会填充空格
3)binary 与Varbinary（二进制字符串）
保存的是字节码而不是字符串,其他的与varchar与char之间基本类似
---binary在检索时会自动填充 \0 会影响检索效果

5(P118) Blob or text 属于超长的字节码和字符串,可以用order by sustring(column,length)来按照其一部分长度进行排序,但是不能用其所有的长度进行索引,也不能用索引来消除排序（need further learning）

6(P124)
1)Enum 类型在插入的时候是不区分大小写的,但是会按照实际的情况按照实际enum的大小写来 format 如 enum为‘DOG’,插入‘doG’ 就会被format成‘DOG’;
2)Enum 字段这是按照内部存储的整数而不是定义的字符串进行排序的。可以在定义的时候按照字母排序来定义或者使用field()函数。
Related SQL:
select enum_name + 0 from table_name;
select * from table_name order by field('enum_name','type1','type2','type3');

7(P121) query_cache_type
query_cache_type
Related SQL:
show variables like '%query_cache%';
set query_cache_type = 0;

8(P125) 在选择标识符（用于与其他表进行比较如在关联操作的时候）,不同表的标志符的字段必须要精确匹配（类型,长度）。（在InnoDB引擎中,类型不完全匹配时不允许创建外键,但是长度不同的varchar是例外）
推荐使用int,不推荐varchar和enum类型.

9(P132)
1)汇总表: 在需要执行需要查询几乎所有的表的操作的时候,可以使用汇总表,先将其汇总信息保存在一个新表中,使用不完全同步的信息,或者使用增量同步的方式实现信息的完全同步
2)缓存表: 对于一个需要很多不同的索引组合俩加速各种类型的查询,可以再创建一相同的表作为缓存表,而在缓存表中使用不同的引擎或者换到不同的系统中。
3)计数器表,应用在表中保存计数器时,可能会导致锁问题,这时可以将计数器保存在很多行中,每次更新的时候,随机选择一项进行更新。

10(P142)
Btree 索引:MySQL 索引的实现是在引擎层的,如果没有指明索引类型,一般都是BTree索引。BTree 索引适用于全键值、键值范围或者键前缀查找。其中键前缀查找只适用于最左键前缀查找。不支持部分索引。
Hash 索引 :  优点,全值查找时速度非常快。
             限制,①哈希索引只保存哈希值和行指针,并不保存数据值,因此不能使用索引中的值来避免读取行。②因为哈希索引不是按照值排序的,因此无法排序。③不支持部分索引值匹配。④只支持等值匹配如=或者<>,不支持范围查询。
                 ④当两行的哈希值相同时（即哈希冲突）,存储引擎必需遍历链表中所有的行指针,逐行匹配。冲突越多,索引查找速度越慢,索引的维护代价越大。

11(P149)
触发器,可用于在指定在数据在被INSERT,UPDATE和DELETE的时候执行指定的操作,其中有BEFORE 和AFTER 两种时间,与对应的条件组合起来共有6种触发器,一个表不可能有两个相同条件下的触发器,因为一个触发器中可以执行多个语句。
DELIMITER $  /*因为在trigger_stmt中可能有很多个语句,语句之间要用";"分隔,而";"在sql中会被认为是一个语句的结束语句,因此将分隔符改成$或者其他符号都可以*/
CREATE TRIGGER trigger_name
BEFORE|AFTER
INSERT|UPDATE|DELETE ON tbl_name
FOR EACH ROW
BEGIN
[trigger_stmt]
END
DELIMITER ;
在trigger_stmt中可以对不同的数据进行操作,其中NEW标识将要被插入的数据,是允许修改的。OLD标识将要被删除的数据,是只读的。

12(P151)
一些其他的索引:空间数据索引,全文索引,分形树索引。

13(P152)
索引的优点:
减少了服务器需要扫描的数据量
帮助服务器避免排序和临时表
将服务器的随机I/O变成了顺序I/O.

判断一个索引是否适合某个查询的三星标准:
索引将相关的数据放到一起,则为一星。
索引中得数据顺序和查找顺序一致,则为二星
索引中的的列包含了查询中需要的全部的列这获得三星。

14（P154）
使用索引时只能将索引作为一个独立的列,不可用于表达式或者函数的参数 如select
前缀索引与索引选择性:
前缀索引即使用某一个字段的一部分来获取建立索引（如果该字段长度过长）。
索引选择性:指不重复的索引的数量a与总的数据量b的比值,比值越大越好

15(P161)
多列索引（选择合适的索引顺序）
索引选择性越高的越靠前。
(索引选择性高的索引在特殊情况下也可能极慢)。




